\documentclass[bachelor, och, pract4, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа

				%    pract2      - отчет по практике,  2 курс
				%    pract3      - отчет по практике,  3 курс
				%    pract4      - отчет по практике,  4 курс
%    nir      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
%\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[english,russian]{babel}

% выделение ссылок цветом. чтобы включить- true
\usepackage[colorlinks=false]{hyperref}

\renewcommand{\rmdefault}{cmr} % курсив и полужирный включаются здесь.
\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\lstdefinestyle{listingStyle}{%
	backgroundcolor=\color{gray!12},
	basicstyle=\ttfamily\small,
	keywordstyle=\color{magenta},
	stringstyle=\color{blue},
	showstringspaces=false,
	captionpos=b,
	numbers=left,
	numberstyle=\footnotesize\color{gray},
	frame=TB,
	tabsize=2
}

\begin{document}

% Кафедра (в родительном падеже)
\chair{теории функций и стохастического анализа} 
%\chairr{кафедра теории функций и стохастического анализа} % для практик!!!!
\chairr{завод "Тантал"}% для практик!!!!

% Тема работы

\title{Правила оформления курсовых и дипломных работ}

% Курс
\course{4}

% Группа
\group{451}

\department{механико-математического факультета}

% Специальность/направление код - наименование
%\napravlenie{01.03.02 "--- Прикладная математика и информатика}
\napravlenie{38.03.05 "--- Бизнес-информатика}
%\napravlenie{09.04.03 "--- Прикладная информатика}

% Для СТУДЕНТКИ!!!. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Чайковского Петра Ильича}

% Заведующий кафедрой
\chtitle{д.\,ф.-м.\,н., доцент} % степень, звание
\chname{С.\,П.\,Сидоров}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{Н.\,Ю.\,Агафонова} % для 451 гр
%\saname{А.\,К.\,Смирнов} % для 412 гр

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{ведущий программист}
\paname{Д.\,Э.\,Кнутов}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{5}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
%\practtype{производственная(базовая)}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
%\duration{4}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{29.06.2019}
\practFinish{26.07.2019}

% Год выполнения отчета
\date{2019}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Введение"
\intro

\par При рассмотрении таких структур данных, как последовательности и списки, особое внимание привлекает простота их определения: последовательность (список)
с базовым типом $ T $ - это либо:
\par 1) пустая последовательность (список); либо
\par 2) конкатенация элемента типа $ T $ и некоторой последовательности с базовым типом $ T $. Для определения принципов построения, а именно следования
или итерации, здесь используется рекурсия. Следования и итерация встречаются настолько часто, что их считают фундаментальными образами строения данных
и поведения программ, однако всегда следует помнить, что их можно определять только с помощью рекурсии (обратное неверно), в то время как рекурсии можно 
эффективно употреблять для определения более сложных структур. Хорошо известным примером служат деревья, которые могут быть определены по следующему
принципу: дерево с базовым типом $ T $ - это либо:
\par 1) пустое дерево; либо
\par 2) некоторая вершина типа $ T $ с конечным числом связанных с ней отдельных деревьев с базовым типом $ T $, называемых \textit{поддеревьями.}
\par Из сходства рекурсивных определений последовательностей и деревьев ясно, что последовательность (список) есть дерево, в котором каждая вершина
имеет не более одного поддерева.

\newpage

\section{Постановка задачи. Описание метода её решения.}

\par Для более корректной постановки задачи сформулируем ещё несколько обязательных определений:
\par \textit{Упорядоченное дерево} - это дерево, у которого рёбра (ветви), исходящие из каждой вершины, упорядочены.
\par \textit{Степень вершины} - число непосредственных потомков внутренней вершины. 
\par Заметим, что особо важную роль при рассмотрении деревьев играют \textit{упорядоченные} деревья \textit{второй степени}. Такие деревья называются 
\textit{бинарными.} Определим упорядоченное двоичное дерево как конечное множество элементов (вершин), которое либо пусто, либо состоит из корня (вершины) 
с двумя отдельными двоичными деревьями, которые называются \textit{левым} и \textit{правым поддеревом} этого корня.
\par Обращаясь же к проблеме представления деревьев, будем описывать как переменные с фиксированной структурой сами вершины, таким образом, их тип будет
зафиксирован, и степень дерева будет определять число ссылочных компонент, указывающих на вершины поддеревьев. Ссылки на пустые деревья будут обозначаться 
значением \textit{NIL}. Таким образом, компоненты дерева имеют такой вид: 

\begin{lstlisting}[caption=Компоненты дерева.,style=listingStyle, language=C++]
TYPE Ptr = POINTER TO Node;
TYPE Node = RECORD op: CHAR;
							left, right: Ptr
						END
\end{lstlisting}

\par Будем считать, что надо строить дерево минимальной глубины, состоящее из $ n $ вершин. В таком случае минимальная высота при заданном числе вершин 
достигается, если на всех уровнях, кроме последнего, помещается
максимальное число вершин. Такого можно добиться, размещая приходящие вершины поровну слева и справа от каждой вершины.
\par Правило равномерного распределения для известного числа вершин $ n $ можно сформулировать, используя рекурсию:
\par 1. Взять одну вершину в качестве корня.
\par 2. Построить тем же способом левое поддерево с $ nl = $ n DIV 2 вершинами.
\par 3. Построить тем же способом правое поддерево с $ nr = $ n - $ nl $ - 1 вершиной.

\par Такому правилу соответствует следующая процедура построения \textit{идеально сбалансированного дерева} (причём будем исходить от следующего
определения: дерево называется \textit{идеально сбалансированным}, если число вершин в его левых и правых поддеревьях отличается не более, чем на 1):

\begin{lstlisting}[caption=Процедура построения идеально сбалансированного дерева., style=listingStyle, language=C++]
PROCEDURE tree(n: INTEGER): Ptr:
	VAR newnode: Ptr;
		x, nl, nr: INTEGER;
 BEGIN 
 	IF n = 0 THEN newnode := NIL
 	ELSE nl := n DIV 2; NR := n - nl - 1;
 		ReadInt(x); ALLOCATE(newnode, SIZE(Node));
 		WITH newnode DO
 			key := x; left := tree(nl); right := tree(nr)
 		END
 	END
 	RETURN newnode
 END tree;
\end{lstlisting}

\newpage

\subsection{Поиск и включение элемента для дерева.}

\par Рассмотрим ситуацию, в ходе процесса которой меняется структура дерева, то есть дерево будет расти или сокращаться в ходе выполнения программы.

\par Рассмотрим случай, когда дерево постоянно растёт, но не убывает. Типичным примером такой задачи будет являться построение частотного словаря.
\par Сформулируем задачу следующим образом: в заранее заданной последовательности надо определить частоту вхождения каждого из слов. Это означает, что
любое слово надо искать в дереве, причём вначале дерево пустое. Если слово найдено, то счётчик его вхождений увеличивается, если нет - это слово включается
в дерево с единичным значением счётчика. Будем называть такую задачу \textit{поиском по дереву с включением.}
\par Приведём код процедуры поиска с включением:

\begin{lstlisting}[caption=Процедура поиска элемента с его включением в дереве., style=listingStyle]
PROCEDURE search(x: INTEGER; VAR p: WPtr):
BEGIN
	IF p = NIL THEN 
		ALLOCATE(p.SIZE(Word));
		WITH p DO
			key := x; count := 1; left := NIL; right := NIL
		END
	ELSIF x < p.key THEN search(x, p.left)
	ELSIF x > p.key THEN search(x, p.right)
	ELSE p.count := p.count + 1
	END
END SEARCH
\end{lstlisting}

\newpage

\subsection{Исключение из деревьев.}

\par Теперь рассмотрим задачу \textit{исключения}. Стоит заметить, что процедура исключения элемента из дерева оказывается простой только в том случае, 
если исключаемый элемент - \text{терминальная} вершина или вершина с одним потомком. Трудность возникает в том случае, когда нужно удалить элемент с 
двумя потомками. В этом случае удаляемый элемент нужно заменить либо на самый правый элемент его левого поддерева, либо на самый левый элемент его 
правого поддерева, причём они должны иметь как максимум одного потомка.
\par Поэтому процедура удаления (исключения) элемента из дерева должна различать три случая:
\par 1. Компоненты с ключом, равным $ x $, нет.
\par 2. Компонента с ключом $ x $ имеет не более одного потомка.
\par 3. Компонента с ключом $ x $ имеет двух потомков.

\par Приведём код рассматриваемой процедуры:
\begin{lstlisting}[caption=Процедура исключения элемента из дерева., style=listingStyle]
PROCEDURE delete(x: INTEGER; VAR p: Ptr):
	VAR q: Ptr;
	
	PROCEDURE del(VAR r: Ptr):
	BEGIN
		IF r.right # NIL THEN del(r.right)
		ELSE q.key := r.key; q.count := r.count;
			q := r; r := r.left
		END
	END del;
	
	BEGIN
		IF p = NIL THEN ( * слова в дереве нет * )
		ELSIF x < p.key THEN delete(x, p.left)
		ELSIF x > p.key THEN delete(x, p.right)
		ELSE ( * исключение p * ) q := p;
			IF q.right = NIL THEN p := q.left
			ELSIF q.left = NIL THEN p := q.right
			ELSE del(q.left)
			END;
	END
END delete
		
\end{lstlisting}

\par Вспомогательная процедура $ del $ начинает работать только в случае 3. Она спускается вдоль правой ветви левого поддерева элемента $ q $, который 
нужно исключить, и заменяет существенную информацию (ключ и счётчик) в $ q $ на соответствующие значения из самой правой компоненты $ r $ левого поддерева,
 после чего от $ q $ можно освободиться.

\section{Вычисление сложности проблемы.}

\subsection{Построение идеально сбалансированного дерева.}

\par К сожалению, не существует быстрых алгоритмов, для выполнения базовых операций для идеально сбаланированных деревьев. Однако, определение идеально сбаланированного дерева, фактически, дает нам алгоритм его построения. Для построения идеально сбаланированного дерева по набору из $ n $ элементов упорядочим этот набор. После этого алгоритм построения дерева сводится к разбиению полученной последовательности $ {a_i}, \, i = 1,\dots, n $ на последовательности  $ {a_i}, \, i = 1,\dots, [n/2] $ и $ {a_i}, \, i = [n/2] + 2,\dots, n. $ Эти последовательности либо имеют равную длину (для нечетных $ n $), либо их длина отличается не более, чем на единицу (для четных $ n $). В корень создаваемого дерева помещаем элемент $ a[n/2]+1 $, а левое и правое поддеревья строим таким же алгоритмом, соответственно, для последовательностей $ {a_i} \, , i = 1,\dots, [n/2] $ и  $ {a_i} \, , i = [n/2] + 2,\dots, n. $

\par Таким образом, приведенный алгоритм доказывает утверждение о том, что идеально сбалансированное дерево поиска, состоящее из $ n $ вершин, можно построить за время, равное $ O(n \cdot \log_2 n) $.

\newpage

\subsection{Поиск элемента в дереве поиска.}

\par Рассмотрим сложность некоторых основных операций, которые можно выполнять над деревом. В качестве таких основных операций рассмотрим \textit{поиск}
в дереве поиска, поиск по дереву с включением и исключение из дерева.

\par Сначала рассмотрим поиск в дереве поиска. \textit{Деревом поиска} будем называть дерево, организованное по следующему правилу: если для каждой
вершины $ t_i $ справедливо, что все ключи левого поддерева $ t_i $ меньше ключа $ t_i $, а все ключи правого поддерева $ t_i $ больше его, то такое 
дерево будем называть \textit{деревом поиска}. В таком дереве можно найти произвольный ключ - достаточно, начав с корня, двигаться по правому или левому
поддереву на основании сравнения с ключом текущей вершины. 
\par Поскольку из $ n $ элементов можно организовать идеально сбалансированное двоичное дерево 
с высотой не более $ \log n $, то поиск в таком дереве среди его $ n $ элементов выполняется максимум за $ \log n $ сравнений, поэтому временная
сложность поиска элемента в дереве поиска будет $ O(\log n) $, где $ n $ - количество узлов в дереве.

\par Приведём код алгоритма поиска в дереве поиска:

\begin{lstlisting}[caption=Процедура поиска элемента в дереве поиска, style=listingStyle]
PROCEDURE locate(x: INTEGER; t: Ptr): Ptr:
BEGIN
	WHILE (t # NIL) & (t.key # x) DO
		IF t.key < x THEN t := t.right ELSE t := t.left END
	END;
	RETURN t
END locate
\end{lstlisting}

\newpage

\subsection{Поиск и включение элемента для дерева.}

\par Предположение о том, что при вставке новых элементов в дерево, оно будет сохранять структуру идеально сбалансированного дерева, является 
идеализированным. Скорее всего, такая структура не будет сохранена, и число сравнений в дереве, сформированном нашим алгоритмом, будет больше. Остаётся
узнать насколько.
\par Начнём с рассмотрения худшего случая. Будем предполагать, что все поступающие ключи идут в строго возрастающем (убывающем) порядке. Тогда каждый 
ключ присоединяется справа (слева) от его предшественника, и в результате мы получим полностью вырожденное дерево, вытянутое в линейный список. В этом
случае средние затраты на поиск равны $ n / 2 $ сравнениям. Такой вариант приводит к неудовлетворительной производительности, но необходимо узнать,
насколько он вероятен, а именно: необходимо узнать усреднённую длину пути для всех $ n $ ключей и для всех $ n! $ деревьев, полученных в результате $ n! $
 перестановок из этих $ n $ исходных ключей. Проведём анализ сложности алгоритма:
 \par Пусть даны $ n $ различных ключей со значениями $ 1, 2, \dots , n, $ причём поступают они в случайном порядке. Вероятность того, что первый ключ,
 который становится корневым узлом, имеет значение $ i $, равна $ 1 / n $. Его левое поддерево будет состоять из $ i - 1 $ вершин, а правое - из $ n - i $ 
 вершин. Обозначим среднюю длину пути в левом поддереве через $ a_{i - 1}, $ а в правом поддереве - через $ a_{n - i} $. Будем вновь предполагать, что 
 все возможные перестановки оставшихся $ n - 1 $ ключей равновероятны. Средняя длина пути в дереве с $ n $ вершинами равна сумме произведений уровня
 каждой вершины на вероятность обращения к ней. 
 \par Также мы можем разделить вершины на три класса:
 \par 1. $ i - 1 $ вершин в левом поддереве имеют среднюю длину пути $ a_{i - 1} $;
 \par 2. корень имеет длину пути 0;
 \par 3. $ n - i $ вершин в правом поддереве имеют среднюю длину пути $ a_{n - i } $.

\par Тогда средняя длина пути с $ n $ вершинами может быть найдена как: 
$$ a_n^{(i)} = \frac{((i - 1) \cdot a_{i - 1} + (n - i) \cdot a_{n - i})}{n}$$ 
\par Искомое значение $ a_n $ - среднее значение $ a_n^{(i)} $ для всех 
$ i = 1, \dots , n $, то есть для всех деревьев с ключами в корне, равными $ 1, 2, \dots , n $: 
$$ a_n = \frac{\sum_{i = 1}^{n} ((i - 1) \cdot a_{i - 1} + (n - i) \cdot a_{n - i})}{n^2} = 2 \cdot \frac{\sum_{i = 1}^{n} (i - 1) \cdot a_{i - 1}}{n^2} = $$
$$ 2 \cdot \frac{\sum_{i = 1}^{n - 1} i \cdot a_i}{n^2}. $$ 
\par Это уравнение представляет собой рекуррентное соотношение вида $ a_n = f_1(a_1, a_2, \dots, a_n). $ Из него мы получаем более простое рекуррентное 
соотношение вида $ a_n = f_2(a_{n - 1}). $ Сначала получаем (1), раскладывая последнее произведение, и (2), подставляя $ n - 1 $ вместо $ n $: \\
\par (1) $ a_n = 2 \cdot (n - 1) \cdot a_{n - 1} / n^2 + 2 \cdot (\sum_{i = 1}^{n - 1} i \cdot a_i) / n^2 $
\par (2) $ a_{n - 1} = 2 \cdot (\sum_{i = 1}^{n - 2} i \cdot a_i) / (n - 1)^2 $ \\ \\
Умножая (2) на $ \displaystyle\frac{(n - 1)^3}{n^2} $, получаем: \\
\par (3) $ 2 \cdot \displaystyle\frac{\sum_{i = 1}^{n - 2} i \cdot a_i}{n^2} = \displaystyle\frac{a_{n - 1} \cdot (n - 1)^2}{n^2} $ \\ \\
и, подставив правую часть (3) в (1), найдём: 
%\par $ a_n = 2 \cdot (n - 1) \cdot a_{n - 1} / n^2 + a_{n - 1} \cdot (n - 1)^2 / n^2 = a_{n - 1} \cdot (n - 1)^2 / n^2 $
\par Заметим, что $ a_n $ можно представить в нерекурсивном замкнутом виде с помощью гармонической функции:
\par $ H_n = 1 + 1/2 + 1/3 + \dots + 1/n \implies a_n = 2 \cdot (H_n \cdot (n + 1) / n - 1) $ \\
Из формулы Эйлера (используя константу $ \gamma = 0.577\dots $):
\par $ H_n = \gamma + \ln n + 1/12n^2 + \dots $ \\ 
получаем для больших $ n $ соотношение $ a_n = 2 \cdot (\ln n + \gamma - 1) $. Так как средняя длина пути в идеально сбалансированном дереве приблизительно
равна $ a_n' = \log n - 1 $, то, опуская слагаемые, которые при больших $ n $ становятся малыми, получаем: \\
\par $ \quad \quad \quad \quad \quad \quad \quad \displaystyle \lim\limits_{n \rightarrow \infty} \frac{a_n}{a_n'} = 2 \cdot \frac{\ln n}{\log n} = 2 \cdot \ln(2) = 1.386\dots $ \\ \\

\par Этот результат означает, что стараясь всегда строить идеально сбалансированное дерево вместо случайного, мы можем ожидать средний выигрыш в длине 
пути поиска не более 30\% при предположении, что все ключи распределены равномерно. 
\par Цифра 39\% накладывает ограничение на объём дополнительных ухищрений для перестройки структуры дерева по мере поступления ключей. При этом имеет
существенное значение отношение частоты обращений (поисков) к вершинам к частоте включений (коррекций дерева). Чем больше это отношение, тем больше 
выигрыш от процедуры перестройки. Однако цифра 39\% достаточно низка, и в большинстве приложений улучшение простого алгоритма поиска с включением не 
оправдывается, если не предусматривается большого числа вершин и большего отношения доступ/включение.

\newpage

\subsection{Исключение элемента из дерева.}

\par Поскольку при удалении вершины из дерева, оно может разбалансироваться, это нужно учитывать в алгоритме удаления элемента из дерева. Таким образом,
процедура удаления вершины $ v $ из сбалансированного дерева поиска сводится к следующему: 
\par 1) Нахождение вершины $ v $, которую надо удалить
\par 2) Её удаления из дерева поиска (с помещением на её место некоторой вершины $ v' $)
\par 3) Для каждой вершины ветви дерева от $ v' $ до корня необходимо проверить условие балансировки - если оно нарушилось, то нужно провести балансировку соответствуюшего поддерева.

Таким образом, в силу построения алгоритма удаления вершины из сбалансированного дерева, верно утверждение о том, что из сбалансированного дерева 
поиска, состоящего из $ n $ вершин, \textit{можно} удалить одну вершину за время $ O(\log_2 n) $.

\section{Программа решения на языке C++.}

\newpage



















\end{document}
