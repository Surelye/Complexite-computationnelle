\documentclass[bachelor, och, pract4, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа

				%    pract2      - отчет по практике,  2 курс
				%    pract3      - отчет по практике,  3 курс
				%    pract4      - отчет по практике,  4 курс
%    nir      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
%\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[english,russian]{babel}

% выделение ссылок цветом. чтобы включить- true
\usepackage[colorlinks=false]{hyperref}

\renewcommand{\rmdefault}{cmr} % курсив и полужирный включаются здесь.
\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\lstdefinestyle{listingStyle}{%
	backgroundcolor=\color{gray!12},
	basicstyle=\ttfamily\small,
	keywordstyle=\color{magenta},
	stringstyle=\color{blue},
	showstringspaces=false,
	captionpos=b,
	numbers=left,
	numberstyle=\footnotesize\color{gray},
	frame=TB,
	tabsize=2
}

\begin{document}

% Кафедра (в родительном падеже)
\chair{теории функций и стохастического анализа} 
%\chairr{кафедра теории функций и стохастического анализа} % для практик!!!!
\chairr{завод "Тантал"}% для практик!!!!

% Тема работы

\title{Правила оформления курсовых и дипломных работ}

% Курс
\course{4}

% Группа
\group{451}

\department{механико-математического факультета}

% Специальность/направление код - наименование
%\napravlenie{01.03.02 "--- Прикладная математика и информатика}
\napravlenie{38.03.05 "--- Бизнес-информатика}
%\napravlenie{09.04.03 "--- Прикладная информатика}

% Для СТУДЕНТКИ!!!. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Чайковского Петра Ильича}

% Заведующий кафедрой
\chtitle{д.\,ф.-м.\,н., доцент} % степень, звание
\chname{С.\,П.\,Сидоров}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{Н.\,Ю.\,Агафонова} % для 451 гр
%\saname{А.\,К.\,Смирнов} % для 412 гр

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{ведущий программист}
\paname{Д.\,Э.\,Кнутов}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{5}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
%\practtype{производственная(базовая)}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
%\duration{4}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{29.06.2019}
\practFinish{26.07.2019}

% Год выполнения отчета
\date{2022}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
%\abbreviations
%\begin{description}
%    \item $|A|$  "--- количество элементов в конечном множестве $A$;
 %   \item $\det B$  "--- определитель матрицы $B$;
 %   \item ИНС "--- Искусственная нейронная сеть;
 %   \item FANN "--- Feedforward Artifitial Neural Network
%\end{description}

% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro

 \par Главное требование при разработке алгоритмов сортировки массивов - экономное использование доступной оперативной памяти. Это означает, что перестановки, с помощью которых упорядочиваются элементы, должны выполняться без затрат дополнительной временной памяти. Ограничивая методы сортировок таким образом, попробуем классифицировать их в соответствии с их временной эффективностью, выражающейся числом перестановок элементов $ M $ или числом необходимых сравнений ключа $ C $. Такая временная эффективность является функцией числа сортируемых элементов $ n $. Хотя хорошие алгоритмы сортировки ограничиваются порядком $ n \cdot log(n) $ сравнений, наиболее простые требуют порядка $ n^2 $ сравнений ключей. Рассмотрим один из наиболее простых алгоритмов сортировки - сортировку пузырьком.

\newpage

\section{Постановка задачи. Описание метода её решения.}

\par Среди алгоритмов сортировки сортировка пузырьком занимает своё место как один из наиболее простых алгоритмов. Как и в других несложных алгоритмах, здесь выполняются повторные проходы по массиву, причём каждый раз наименьший элемент оставшегося множества просеивается в направлении одного из концов массива (в зависимости от того, происходит ли сортировка по убыванию или по возрастанию). Своё название алгоритм получил как раз из-за схожести процесса подъёма пузырьков воздуха в сосуде с водой с просеиванием элемента к одному из концов массива. Рассмотрим псевдокод "наивной" реализации алгоритма сортировки пузырьком: \\


	\begin{lstlisting}[caption=Алгоритм сортировки пузырьком.,style=listingStyle, language=C++]
PROCEDURE BubbleSort;
	VAR i, j: INTEGER; x: Item;
BEGIN
	FOR i := 1 TO n 1 DO
		FOR j := n - 1 TO i BY -1 DO
			IF a[j - 1] > a[j] THEN
				x := a[j - 1]; a[j - 1] := a[j]; a[j] := x
			END
		END
	END
END BubbleSort
	\end{lstlisting}
\par Этот алгоритм нетрудно улучшить. Рассмотрение примеров показывает, что в некоторых случаях алгоритм продолжает работу при уже отсортированном массиве. Очевидный способ улучшить алгоритм - запоминать, был ли осуществлён хотя бы один обмен во время прохода. Тогда проход без обменов будет означать, что алгоритм может быть остановлен. Возможно также ещё одно улучшение - запоминать не только факт обмена, но и позицию (индекс) последнего обмена. Ясно, что все пары соседних элементов левее этого значения индекса уже упорядочены, поэтому последующие проходы могут останавливаться на этом значении индекса, вместо того, чтобы продолжаться до $ i $. Также возможно и третье усовершенствование: 
менять направление последовательных проходов. Получившийся алгоритм называется "шейкер-сортировкой" и является модификацией алгоритма сортировки пузырьком. Рассмотрим псевдокод
этого алгоритма: \\

\begin{lstlisting}[caption=Алгоритм шейкер-сортировки.,style=listingStyle]
PROCEDURE ShakerSort;
	VAR j, k, L, R: INTEGER; x: Item;
BEGIN
	L := 1; R := n - 1; k := R;
	REPEAT
		FOR j := R TO L BY -1 DO
			IF a[j - 1] > a[j] THEN
				x := a[j - 1]; a[j - 1] := a[j]; a[j] := x; k := j;
			END
		END
		L := k + 1;
		FOR j := L TO R BY +1 DO
			IF a[j - 1] > a[j] THEN
				x := a[j - 1]; a[j - 1] := a[j]; a[j] := x; k := j
			END
		END
		R := k - 1
	UNTIL L > R
END ShakerSort
\end{lstlisting}

\newpage 

\section{Вычисление сложности алгоритма.}

Оценим число сравнений в простой пузырьковой сортировке. В среднем оно будет равно $ \displaystyle C = \frac{n^2 - n}{2}, $ а минимальное, среднее и максимальное числа 
присваиваний элементов равны: $$ M_{min} = 0, \quad M_{avg} = \frac{3}{4} (n^2 - n), \quad M_{max} = \frac{3}{2}(n^2 - n). $$ 
\par Анализ улучшенных вариантов, особенно шейкер-сортировки, довольно сложен. Наименьшее число сравнений здесь равно $ C_{min} = n - 1 $. Для улучшенной пузырьковой сортировки Дональд Кнут нашёл, что среднее число проходов пропорционально величине $ n - k_1 \sqrt n $, а среднее число сравнений - величине: $ (n^2 - n \cdot (k_2 + \ln n)) / 2. $ Однако ни одно из упомянутых улучшений не может 
повлиять на число обменов, уменьшается только число избыточных проверок, поэтому все улучшения имеют меньший эффект, чем могло ожидаться - обмен двух элементов более 
затратная, нежели сравнение ключей, операция.

\par Подобный анализ показывает, что сортировка пузырьком и её небольшие улучшения хуже, чем сортировка вставками и сортировка выбором, поэтому является малоэффективным алгоритмом сортировки. Шейкер-сортировка эффективна в тех случаях, когда элементы уже стоят в почти правильном порядке.

\newpage


\section{Программа решения на языке C++.}

По полученным псевдокодам напишем программу на языке программирования C++. Программа будет содержать реализацию алгоритма сортировки пузырьком и шейкерной сортировки.

\begin{lstlisting}[caption=Программа алгоритмов сортировки пузырьком и шейкерной сортировки.,style=listingStyle, language=C++]
#include<iostream>
#include<vector>

using namespace std;

const int numberOfValues = 10;
const int divisionValue = 97;
	
void generateVector(vector<int>& values)
{
	int i;
	
	for (i = 0; i < numberOfValues; ++i)
		values[i] = rand() % divisionValue;
}

void displayVector(vector<int> values)
{
	for (int value : values)
		cout << value << " ";
}

void shakerSort(vector<int>& values)
{
	int left, right, i;
	
	left = 0; right = values.size() - 1;
	
	do
	{
		for (i = right; i > left; --i)
		{
			if (values[i] < values[i - 1])
				swap(values[i], values[i - 1]);
		}
		left++:
		
		for (i = left; i < right; ++i)
		{
			if (values[i] > values[i + 1])
				swap(values[i], values[i + 1]);
		}
		right--;
	}
	while (left <= right);
}

void bubbleSort(vector<int>& values)
{
	int i, j;
	
	for (i = 0; i < numberOfValues; ++i)
		for (j = numberOfValues - 1; j > i; --j)
			if (values[j - 1] > values[j])
				swap(values[j - 1], values[j]);
}

int main() 
{
	srand(time(0));
	
	vector<int> values(numberOfValues, 0);
	generateVector(values);
	
	cout << "Случайно сгенерированные числа:\n";
	displayVector(values);
	
	cout << "\nОтсортированные элементы:\n";
	bubbleSort(values);
	displayVector(values);
	
	cout << "\n\nСлучайно сгенерированные числа:\n";
	generateVector(values);
	displayVector(values);
	
	cout << "\nОтсортированные элементы:\n";
	shakerSort(values);
	displayVector(values);
}

\end{lstlisting}

\par Для хранения элементов, которые нужно отсортировать, будем пользоваться структурой "вектор". Для демонстрации работы алгоритма будем генерировать 
вектор случайных значений, содержащий 10 чисел. Генерацию и вывод случайных значений будем осуществлять при помощи вспомогательных функций
\textit{generateVector()} и \textit{displayVector()}. 
\par Сначала протестируем алгоритм сортировки пузырьком, расположенный на 48 - 56 строках программы. Сгенерируем вектор случайных значений и попробуем 
его отсортировать: 
\begin{figure}[h]
	\center{\includegraphics{bubbleSortTest}}
	\caption*{\textit{Рис. 1} - Входные и выходные данные для алгоритма сортировки пузырьком.}
\end{figure}

\par Как видно, алгоритм справляется со своей задачей. Теперь рассмотрим шейкерную сортировку. Сгенерируем новый вектор из 10 случайных значений и 
посмотрим на результат выполнения алгоритма. 
\begin{figure}[h]
	\center{\includegraphics{shakerSortTest}}
	\caption*{\textit{Рис. 2} - Входные и выходные данные для алгоритма шейкерной сортировки.}
\end{figure}
\par Видно, что алгоритм справляется с поставленной задачей. Разберём его подробнее.
Основная часть работы выполняется на строках 29 - 45. При входе в функцию инициализируются два значения - $ left $ и $ right $ - изначально они указывают 
на начало и конец вектора соответственно. Далее, элементы начинают обрабатываться в цикле. В строках 31 - 35 выполняется сдвиг к началу вектора более 
"легких" элементов - меньших по значению. В строках 38 - 42 осуществляется сдвиг к концу вектора более "тяжёлых" элементов, больших по значению. Как 
видно, такие сдвиги 
осуществляются поочерёдно - сначала продвигаются меньшие, а затем большие значения. После каждого такого цикла значение $ left $ увеличивается, а значение
$ right $ уменьшается, что означает, что все элементы, стоящие до $ left $ и после $ right $, стоят на своих местах. Внешний цикл продолжается до тех пор, 
пока значения $ left $ и $ right $ не совпадут. 

\newpage

\conclusion

\par В ходе проведённого анализа было выявлено, что алгоритм пузырьковой сортировки и его разнообразные модификации являются малоэффективными алгоритмами сортировок. Причиной 
этому является тот факт, что все простые методы сортировок перемещают элемент на одну позицию на каждом элементарном шаге, поэтому всегда требуют порядка $ n^2 $ таких шагов. 
Любое серьёзное усовершенствование должно иметь целью увеличение расстояния, на которое перемещаются элементы в каждом прыжке. Такой способ перемещения элементов реализован, например, в сортировках вставками, выбором и обменами.

%\begin{thebibliography}
%\par 1. Зорин А.В. Моделирование случайных величин и проверка гипотез о виде %распределения. [Текст]: учебно-методическое пособие / А.В. Зорин // Нижний Новгород: %Нижегородский университет, 2017. - 19 с. 	
%\end{thebibliography}


\end{document}
